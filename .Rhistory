),
storage = list(
type = STORAGE_TYPES$FLATFILE,
path = "responses"
),
name = "Personal info",
password = "shinyforms",
reset = TRUE,
validations = list(
list(condition = "nchar(input$name) >= 3",
message = "Name must be at least 3 characters"),
list(condition = "input$terms == TRUE",
message = "You must agree to the terms")
)
)
# Define the second form: soccer
soccerFormInfo <- list(
id = "soccerform",
questions = list(
list(id = "team", type = "text", title = "Favourite soccer team"),
list(id = "player", type = "text", title = "Favourite player")
),
storage = list(
type = STORAGE_TYPES$FLATFILE,
path = "soccer"
),
multiple = FALSE
)
ui <- fluidPage(
h1("shinyforms example"),
tabsetPanel(
tabPanel(
"Basic info",
formUI(basicInfoForm)
),
tabPanel(
"Soccer",
formUI(soccerFormInfo)
)
)
)
server <- function(input, output, session) {
formServer(basicInfoForm)
formServer(soccerFormInfo)
}
shinyApp(ui = ui, server = server)
library(shiny)
library(shinyjs)
ui <- fluidPage(
useShinyjs(),  # Include shinyjs
actionButton("button", "Click me"),
textInput("text", "Text")
)
server <- function(input, output) {
observeEvent(input$button, {
toggle("text")  # toggle is a shinyjs function
})
}
shinyApp(ui, server)
library(shiny)
library(lubridate)
ui <- function(){
tagList(
# Adding a first input which allow
# to select a specific date
dateInput(
"date",
"choose a date"
),
# Adding a second input allowing
# to specify a year
selectInput(
"year",
"Choose a year",
choices = 2010:2030
)
)
}
server <- function(
input,
output,
session
){
# We want the year to be update whenever
# the dateInput is updated
observeEvent( input$date , {
updateSelectInput(
session,
"year",
selected = year(input$date)
)
})
# We want the date to be update whenever
# the selectInput is updated
observeEvent( input$year , {
updateDateInput(
session,
"date",
value = lubridate::as_date(
sprintf("%s-01-01", input$year)
)
)
})
}
shinyApp(ui, server)
i
## DO NOT DO GLOBAL VARIABLES, IT'S JUST TO SIMPLIFY THE EXAMPLE
# We initiate a counter that will help to track how many times
# some pieces of the code are called
i <- 0
library(shiny)
library(cli)
ui <- function(){
tagList(
# We are adding a simple text input
# that will be printed to the console
textInput("txt", "Text")
)
}
server <- function(input, output, session){
observe({
# Every time this reactive context is invalidated,
# we add 1 to the i value
i <<- i + 1
# We print the i value to the console,
# and the value of input$txt
cat_rule(as.character(i))
print(input$txt)
})
}
shinyApp(ui, server)
cat_rule(i)
i <- 0
library(shiny)
library(cli)
ui <- function(){
tagList(
# We are adding a simple text input
# that will be printed to the console
textInput("txt", "Text"),
# We add a selectInput() to allow text transformation
selectInput(
"casefolding",
"Casefolding",
c("lower", "upper")
)
)
}
server <- function(input, output, session){
observe({
# Every time this reactive context
# is invalidated, we add 1 to the i value
i <<- i + 1
# We print the i value to the console
cat_rule(as.character(i))
# If the user select lower, then the text is
# passed through tolower, otherwise it's passed
# through toupper
if (input$casefolding == "lower") {
print(tolower(input$txt))
} else  {
print(toupper(input$txt))
}
})
}
shinyApp(ui, server)
i <- 0
library(shiny)
library(cli)
library(stringi)
ui <- function(){
tagList(
# We are adding a simple text input
# that will be printed to the console
textInput("txt", "Text"),
# We add a selectInput() to allow text transformation
selectInput(
"casefolding",
"Casefolding",
c("lower", "upper")
)
# A new checkbox to reverse (or not) the input text
checkboxInput("rev", "reverse")
)
}
server <- function(input, output, session){
observe({
# Every time this reactive context
# is invalidated, we add 1 to the i value
i <<- i + 1
# We print the i value to the console
cat_rule(as.character(i))
# Use input_txt as a container for our input
input_txt <- input$txt
if (input$rev){
# If the input$rev is select, we reverse the text
input_txt <- stri_reverse(input_txt)
}
# If the user select lower, then the text is
# passed through tolower, otherwise it's passed
# through toupper
if (input$casefolding == "lower") {
print(tolower(input_txt))
} else  {
print(toupper(input_txt))
}
})
}
shinyApp(ui, server)
i <- 0
library(shiny)
library(cli)
library(stringi)
ui <- function(){
tagList(
# We are adding a simple text input
# that will be printed to the console
textInput("txt", "Text"),
# We add a selectInput() to allow text transformation
selectInput(
"casefolding",
"Casefolding",
c("lower", "upper")
)
# A new checkbox to reverse (or not) the input text
checkboxInput("rev", "reverse")
)
}
server <- function(input, output, session){
observe({
# Every time this reactive context
# is invalidated, we add 1 to the i value
i <<- i + 1
# We print the i value to the console
cat_rule(as.character(i))
# Use input_txt as a container for our input
input_txt <- input$txt
if (input$rev){
# If the input$rev is select, we reverse the text
input_txt <- stri_reverse(input_txt)
}
# If the user select lower, then the text is
# passed through tolower, otherwise it's passed
# through toupper
if (input$casefolding == "lower") {
print(tolower(input_txt))
} else  {
print(toupper(input_txt))
}
})
}
shinyApp(ui, server)
library(shiny)
library(gargoyle)
ui <- function(){
fluidPage(
tagList(
# Creating an action button to launch the computation
actionButton("compute", "Compute"),
# Output for all runif()
verbatimTextOutput("result"),
# This output will change only if runif() > 0.5
verbatimTextOutput("result2"),
# This button will reset x$results to 0, we use it
# to show that it won't launch a series of reactivity
# invalidation
actionButton("reset", "Reset x")
)
)
}
server <- function(
input,
output,
session
){
# Mimic an R6 class, i.e a non-reactive object
x <- environment()
# Creating two watchers
init("render_result", "render_result2")
observeEvent( input$compute , {
# When the user presses compute, we launch runif()
x$results <- runif(1)
# Every time a new value is stored, we render result
trigger("render_result")
# Only render the second result if x$results is over 0.5
if (x$results > 0.5){
trigger("render_result2")
}
})
output$result <- renderPrint({
# Will be rendered every time
watch("render_result")
# require x$results before rendering the output
req(x$results)
x$results
})
output$result2 <- renderPrint({
# This will only be rendered if trigger("render_result2")
# is called
watch("render_result2")
req(x$results)
x$results
})
observeEvent( input$reset , {
# This resets x$results. This code block is here
# to show that reactivity is not triggered in this app
# unless a trigger() is called
x$results <-  0
print(x$results)
})
}
shinyApp(ui, server)
remotes::install_github("ColinFay/gargoyle")
library(shiny)
library(gargoyle)
ui <- function(){
fluidPage(
tagList(
# Creating an action button to launch the computation
actionButton("compute", "Compute"),
# Output for all runif()
verbatimTextOutput("result"),
# This output will change only if runif() > 0.5
verbatimTextOutput("result2"),
# This button will reset x$results to 0, we use it
# to show that it won't launch a series of reactivity
# invalidation
actionButton("reset", "Reset x")
)
)
}
server <- function(
input,
output,
session
){
# Mimic an R6 class, i.e a non-reactive object
x <- environment()
# Creating two watchers
init("render_result", "render_result2")
observeEvent( input$compute , {
# When the user presses compute, we launch runif()
x$results <- runif(1)
# Every time a new value is stored, we render result
trigger("render_result")
# Only render the second result if x$results is over 0.5
if (x$results > 0.5){
trigger("render_result2")
}
})
output$result <- renderPrint({
# Will be rendered every time
watch("render_result")
# require x$results before rendering the output
req(x$results)
x$results
})
output$result2 <- renderPrint({
# This will only be rendered if trigger("render_result2")
# is called
watch("render_result2")
req(x$results)
x$results
})
observeEvent( input$reset , {
# This resets x$results. This code block is here
# to show that reactivity is not triggered in this app
# unless a trigger() is called
x$results <-  0
print(x$results)
})
}
shinyApp(ui, server)
runApp('D:/R Projects/CustomerAttribution')
runApp('D:/R Projects/CustomerAttribution')
env0
env0[[1]]
class(env0)
env0$exe_demo
env0$R
runApp('D:/R Projects/CustomerAttribution')
runApp('D:/R Projects/CustomerAttribution')
library(shiny)
library(gargoyle)
ui <- function(){
fluidPage(
tagList(
# Creating an action button to launch the computation
actionButton("compute", "Compute"),
# Output for all runif()
verbatimTextOutput("result"),
# This output will change only if runif() > 0.5
verbatimTextOutput("result2"),
# This button will reset x$results to 0, we use it
# to show that it won't launch a series of reactivity
# invalidation
actionButton("reset", "Reset x")
)
)
}
server <- function(
input,
output,
session
){
# Mimic an R6 class, i.e a non-reactive object
x <- environment()
# Creating two watchers
init("render_result", "render_result2")
observeEvent( input$compute , {
# When the user presses compute, we launch runif()
x$results <- runif(1)
# Every time a new value is stored, we render result
trigger("render_result")
# Only render the second result if x$results is over 0.5
if (x$results > 0.5){
trigger("render_result2")
}
})
output$result <- renderPrint({
# Will be rendered every time
watch("render_result")
# require x$results before rendering the output
req(x$results)
x$results
})
output$result2 <- renderPrint({
# This will only be rendered if trigger("render_result2")
# is called
watch("render_result2")
req(x$results)
x$results
})
observeEvent( input$reset , {
# This resets x$results. This code block is here
# to show that reactivity is not triggered in this app
# unless a trigger() is called
x$results <-  0
print(x$results)
})
}
shinyApp(ui, server)
library(shiny)
ui <- fluidPage(
headerPanel("Example eventReactive"),
mainPanel(
# input field
textInput("user_text", label = "Enter some text:", placeholder = "Please enter some text."),
# submit button
actionButton("submit", label = "Submit"),
# display text output
textOutput("text"))
)
server <- function(input, output) {
# reactive expression
text_reactive <- eventReactive( input$submit, {
input$user_text
})
# text output
output$text <- renderText({
text_reactive()
})
}
shinyApp(ui = ui, server = server)
library(shiny)
ui <- fluidPage(
headerPanel("Example reactive"),
mainPanel(
# action buttons
actionButton("button1","Button 1"),
actionButton("button2","Button 2")
)
)
server <- function(input, output) {
# observe button 1 press.
observe({
input$button1
input$button2
showModal(modalDialog(
title = "Button pressed",
"You pressed one of the buttons!"
))
})
}
shinyApp(ui = ui, server = server)
library(shiny)
ui <- fluidPage(
headerPanel("Example reactive"),
mainPanel(
# action buttons
actionButton("button1","Button 1"),
actionButton("button2","Button 2")
)
)
server <- function(input, output) {
# observe button 1 press.
observeEvent(input$button1, {
# The observeEvent takes no dependency on button 2, even though we refer to the input in the following line.
input$button2
showModal(modalDialog(
title = "Button pressed",
"You pressed one of the buttons!"
))
})
}
shinyApp(ui = ui, server = server)
library(descriptr)
ds_launch_shiny_app()
ds_launch_shiny_app()
ds_launch_shiny_app()
runApp()
runApp()
